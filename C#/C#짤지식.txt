C#

 .NET Framework 기반 프로그램 개발할 때 사용하는 프로그래밍 언어
c++ 진보한 버전
c++  -> c#
 ++

C# 소스파일을 컴파일하면 C# 컴파일러에 의해 .NET 어셈블리(.NET 프레임워크에서 동작 가능한 이진 파일)가 작성됨.
 .NET 프레임워크의 핵심 역할을 담당하는 CLR에 의해 .NET 어셈블리를 로드하고 Jitter(Just In Time Compiler)에 의해 MSIL(.NET 어셈블리내에 코드를 MSIL이라 부름)코드를 실제 운영체제에서 동작 가능한 기계어 명령으로 변환하여 가동됨.
(CLR: common language runtime)

과정은 많아졌으나 상호 참조가 쉬워졌으며  jit 컴파일러를 거치는 시간은 매우 짧다.

- C# 프로젝트 제작
콘솔앱 (.NET Framework)으로 제작
위에 using은 사용하면 흐린상태에서 불이 들어온다

최소 하나 이상의 클래스를 가져야한다.
class는 필드와 메소드가 존재
전역함수가 존재하지 않는다. 오직 메소드만 존재
메인은 스태틱
static void Main();
static int Main();
static int Main(string[] args);
static void Main(string[] args);

C#은 포인터를 지원하지 않는다.
기본 타입(int, char, float ....) 이외에는 전부 class 형식이라 객체를 만들어야한다. new
C#에서 객체는 반드시 new로 생성해야하므로 힙 영역에 할당된다


stack 영역 heap영역은 공통
static 영역 : 프로그램 코드, static 멤버가 존재
보통 클래스 멤버는 인스턴스를 생성해야 접근 가능하므로 인스턴스 멤버라고 한다.
스태틱 멤버는 class.~~ 으로 접근

멤버변수는 초기화 딱히 안해주면
숫자는 0
char 는 '\0'
string 타입은 null로 초기화 됨


C#기준 인터페이스에서 사용 가능한것. 접근제한자 별도 지정 x (무조건 public)
메소드
이벤트
프로퍼티
인덱서

암묵적 약속으로 인터페이스 앞에는 I를 붙인다

인터페이스 도입 이유
- C#은 다중상속을 막는다. (모호성 때문에 대다수 언어가 허용을 하지 않음)
다중상속을 막음에 따른 불편함에 인터페이스를 만듬. 인터페이스는
다중 상속 가능. 인터페이스를 상속한다는 표현보다 구현을 한다라는 표현을 사용
inheritence, implementation
- 사용방법은 정해졌으나 구현방법은 정해지지 않았을때 추상클래스를 사용.
쓰다보니 생성자, 소멸자, 필드 멤버 같은거 하나도 없이 추상 메소드만 
들어있는 것을 많이 사용.
클래스는 생성자 소멸자 필드 등 구현때 오버헤드가 커진다.
인터페이스는 해당 부분을 전부 없에서 가벼운 상태이다.
많이 쓸거면 가벼운 인터페이스를 사용한다.

프로퍼티
변수명을 앞글자 대문자로 프로퍼티 이름 설정

쓰레드 정지
Thread.abort()는 강제로 죽이는 거라 위험부담이 있으므로 사용을 지양한다.
대신 flag를 사용 가능한 환경이면 flag 사용을 권고한다.
flag 못쓰는 상황이면 interrupt를 건다.
인터럽트는 대상 쓰레드가 wait sleep join 상태에 있을경우 깨워준다.
따라서 해당 작업을 마무리하고 유후상태로 있을때 인터럽트가 되므로 안정적

실행만 시키고 도중 작업 필요없을때는 task 쓴다.
fire & forget 발사하고 잊어버린다. 실행만 시켜놓으면 될거라 생각하고 딴일함

async : 메소드 이벤트 처리기, 태스크 , 람다식
async로 한정하는 메소드는 반환형식이 Task, Task<TResult>, void 이여야만 한다
Task,Task<TResult> 타입 메소드는 메소드 내부에 await 연산자를 만나면 호출자에게 제어권 넘김 (await 연산자가 없으면 동기방식으로 진행)


글로벌 어셈블리 캐쉬라는 영역이 존재.
서명이 존재하는 dll만 등록이 가능하다. key 파일이 존재하면 자유롭게 dll 
수정가능 128비트 암호화 되어있으므로 해킹도 힘듬

링크
Language INtegraged Query